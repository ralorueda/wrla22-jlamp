load smt.maude

mod FT-CHANNEL is 
    protecting INTEGER .
    protecting TRUTH-VALUE .

    sorts IntegerList . 
    subsorts Integer < IntegerList .

    op nil : -> IntegerList [ctor] .
    op _;_ : IntegerList IntegerList -> IntegerList [ctor assoc] .

    vars N M : Integer .   vars L Q : IntegerList .

    eq L ; nil = L [variant] .
    eq nil ; L = L [variant] .
    eq L ; nil ; Q = L ; Q [variant] . *** B-coherence extension

    sorts Msg MsgSet Channel .
    subsorts Msg < MsgSet .

    op null : -> MsgSet [ctor] .
    op __ : MsgSet MsgSet -> MsgSet [ctor assoc comm] .
    op [_,_]_[_,_] : IntegerList Integer MsgSet IntegerList Integer -> Channel [ctor] .
    op {_,_} : Integer Integer -> Msg [ctor] .
    op ack : Integer -> Msg [ctor] .
    op empty : MsgSet -> Boolean .

    vars I J K : Integer .    vars P R : IntegerList .
    var MSG : Msg .    vars S S' : MsgSet .    vars CH CH' : Channel .

    eq S null = S [variant] .
    eq S S = S [variant] . *** set idempotency
    eq S S S' = S S' [variant] . *** B-coherence extension

    eq empty(null) = true [variant] .
    eq empty(MSG S) = false [variant] .

    rl [send] : [J ; L,N] S [P,M] => [J ; L,N] {J,N} S [P,M] [narrowing] .

    crl [recv-1] : [L,N] {J,K} S [P,M] => [L,N] S ack(K) [P ; J, M + 1] 
                    if (K === M) = true .

    crl [recv-2] : [L,N] {J,K} S [P,M] => [L,N] S ack(K) [P,M] 
                    if (K =/==  M) = true .

    crl [ack-recv-1] : [J ; L,N] ack(K) S [P,M] => [L,N + 1] S [P,M] 
                    if (K ===  N) = true .

    crl [ack-recv-2] : [J ; L,N] ack(K) S [P,M] => [J ; L,N] S [P,M] 
                    if (K =/==  N) = true .
endm